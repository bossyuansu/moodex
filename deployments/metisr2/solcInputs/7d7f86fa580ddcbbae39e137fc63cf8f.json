{
  "language": "Solidity",
  "sources": {
    "contracts/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0; \npragma abicoder v2;\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./MathHelper.sol\";\nimport \"./IERC20Minimal.sol\";\nimport \"./OrderedSet.sol\";\n\ncontract OrderBook{ \n\n   using OrderedSet for OrderedSet.Set;\n   using OrderedUint256Set for OrderedUint256Set.Set;\n   event NewEntry(address user, bool isBuy, uint256 price, uint256 amount);\n   event Transaction(address buyer, address seller, uint256 price, uint256 amount);\n   uint16 public constant SIG_DIGITS=5;  //# of significant digits\n   uint16 public constant MAX_DEPTH=100;\n\n   uint public maxPrecision;\n\n   OrderedUint256Set.Set private buyBook;\n   OrderedUint256Set.Set private sellBook;\n\n   mapping(uint256=>OrderedSet.Set) private theBook;\n   mapping(address=>mapping(uint256=>uint256)) public amounts;\n\n   // latest transaction price\n   uint256 curPrice;\n\n   IERC20Minimal public Base;\n   IERC20Minimal public Token;\n\n   using Counters for Counters.Counter;\n\n   Counters.Counter private _tokenIds;\n\n   constructor(IERC20Minimal base, IERC20Minimal token) public {\n      Base = base;\n      Token = token;\n      maxPrecision = 0;\n   }\n\n   function order(uint256 price, uint256 amount, bool isBuy) public {\n      if (isBuy) {\n         buy(price, amount);\n      } else {\n         sell(price, amount);\n      }\n   }\n   function buy(uint256 price, uint256 amount) internal \n   {\n      Base.transferFrom(msg.sender, address(this), amount);\n      uint256 transferAmount = 0;\n      address user = msg.sender;\n      // case 1, if the order is below the current market\n      uint256 tmpPrice = OrderedUint256Set.head(sellBook);\n      if (price < tmpPrice || tmpPrice == 0) {\n         addOrderEntry(price, amount, true);\n      }\n\n      address tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n      for (uint256 i=0; i < MAX_DEPTH && amount > 0 && price >= tmpPrice; ++i) \n      {\n         uint256 orderAmount = amounts[tmpOwner][tmpPrice];\n         uint256 txAmount;\n         if (orderAmount >= amount) { //meaning the current order can fill\n            txAmount = amount;\n         } else {\n            txAmount = orderAmount;\n         }\n         amounts[tmpOwner][tmpPrice] -= txAmount;\n         transferAmount += txAmount;\n         emit Transaction(tmpOwner, user, tmpPrice, txAmount);\n         amount -= txAmount;\n         curPrice = tmpPrice;\n\n         if (amounts[tmpOwner][tmpPrice] == 0) {\n            OrderedSet.remove(theBook[tmpPrice], tmpOwner);\n            tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n            if (tmpOwner == address(0)) {\n                OrderedUint256Set.remove(sellBook, tmpPrice);\n                delete theBook[tmpPrice];\n                tmpPrice = OrderedUint256Set.head(sellBook);\n                if (tmpPrice == 0) {\n                   break;\n                }\n                tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n            }\n         }\n      }\n\n      if (amount > 0 && (price < tmpPrice || tmpPrice == 0) ) {\n         addOrderEntry(price, amount, true);\n      }\n\n      Token.transferFrom(address(this), msg.sender, transferAmount);\n   }\n\n   function sell(uint256 price, uint256 amount) internal \n   {\n      Token.transferFrom(msg.sender, address(this), amount);\n      address user = msg.sender;\n      // case 1, if the order is below the current market\n      uint256 tmpPrice = OrderedUint256Set.head(buyBook);\n      uint256 transferAmount = 0;\n      if (price > tmpPrice || tmpPrice == 0) {\n         addOrderEntry(price, amount, true);\n      }\n\n      address tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n      for (uint256 i=0; i < MAX_DEPTH && amount > 0 && price <= tmpPrice; ++i) \n      {\n         uint256 orderAmount = amounts[tmpOwner][tmpPrice];\n         uint256 txAmount;\n         if (orderAmount >= amount) { //meaning the current order can fill\n            txAmount = amount;\n         } else {\n            txAmount = orderAmount;\n         }\n         amounts[tmpOwner][tmpPrice] -= txAmount;\n         emit Transaction(user, tmpOwner, tmpPrice, txAmount);\n         amount -= txAmount;\n         transferAmount += txAmount * tmpPrice / 10^18;\n         curPrice = tmpPrice;\n\n         if (amounts[tmpOwner][tmpPrice] == 0) {\n            OrderedSet.remove(theBook[tmpPrice], tmpOwner);\n            tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n            if (tmpOwner == address(0)) {\n                OrderedUint256Set.remove(buyBook, tmpPrice);\n                delete theBook[tmpPrice];\n                tmpPrice = OrderedUint256Set.head(buyBook);\n                if (tmpPrice == 0) {\n                   break;\n                }\n                tmpOwner = OrderedSet.head(theBook[tmpPrice]);\n            }\n         }\n      }\n\n      if (amount > 0 && (price > tmpPrice || tmpPrice == 0) ) {\n         addOrderEntry(price, amount, false);\n      }\n      Base.transferFrom(address(this), msg.sender, transferAmount);\n   }\n\n   function removeOrderEntry(uint256 price) public {\n      require(amounts[msg.sender][price] > 0, \"invalid order amount\");\n      OrderedSet.remove(theBook[price], msg.sender);\n      if (OrderedSet.head(theBook[price]) == address(0)) {\n         if (price <= OrderedUint256Set.head(buyBook)) {\n            OrderedUint256Set.remove(buyBook, price);\n         } else {\n            OrderedUint256Set.remove(sellBook, price);\n         }\n\n         delete theBook[price];\n      }\n   }\n   function addOrderEntry(uint256 price, uint256 amount, bool isBuy) public {\n      uint256 prevPrice = 0;\n      if (maxPrecision != 0) {\n         uint length = bytes(uint2str(price)).length;\n         require(length > maxPrecision, \"the price is too granular\");\n         price -= price % MathHelper.pow(10, maxPrecision);\n      }\n\n      require(price > 0, \"price cannot be zero\");\n      if (isBuy) {\n         uint256 tmpPrice = OrderedUint256Set.head(buyBook);\n         for (uint i = 0; price > tmpPrice && tmpPrice != 0; ++i) {\n            require (i < MAX_DEPTH, \"The order is too deep\");\n            prevPrice = tmpPrice;\n            tmpPrice = buyBook.next[tmpPrice];\n         }\n         if (price != tmpPrice) {\n            OrderedUint256Set._insert(buyBook, prevPrice, price, tmpPrice);\n         }\n\n         OrderedSet.append(theBook[price], msg.sender);\n         amounts[msg.sender][price] += amount;\n\n         uint tmpLength = bytes(uint2str(OrderedUint256Set.head(buyBook))).length;\n         if (tmpLength > SIG_DIGITS) {\n            maxPrecision = tmpLength - SIG_DIGITS; \n         }\n      } else {\n         uint256 tmpPrice = OrderedUint256Set.head(sellBook);\n         for (uint i = 0; price < tmpPrice && tmpPrice != 0; ++i) {\n            require (i < MAX_DEPTH, \"The order is too deep\");\n            prevPrice = tmpPrice;\n            tmpPrice = sellBook.next[tmpPrice];\n         }\n         if (price != tmpPrice) {\n            OrderedUint256Set._insert(sellBook, prevPrice, price, tmpPrice);\n         }\n\n         OrderedSet.append(theBook[price], msg.sender);\n         amounts[msg.sender][price] += amount;\n         uint tmpLength = bytes(uint2str(OrderedUint256Set.head(sellBook))).length;\n         if (tmpLength > SIG_DIGITS) {\n            maxPrecision = tmpLength - SIG_DIGITS; \n         }\n      }\n   }\n\n   function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint j = _i;\n        uint len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n   function str2uint(string memory s) internal pure returns (uint) {\n      bytes memory b = bytes(s);\n      uint result = 0;\n      for (uint i = 0; i < b.length; i++) { \n         if (uint8(b[i]) >= 48 && uint8(b[i]) <= 57) {\n            result = result * 10 + (uint8(b[i]) - 48); \n         }\n      }\n      return result;\n   }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/MathHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nlibrary MathHelper {\n\n\n    // x^n\n    function pow (uint x, uint n)\n    internal pure returns (uint r) {\n       r = 1.0;\n       while (n > 0) {\n           if (n % 2 == 1) {\n              r *= x;\n              n -= 1;\n           } else {\n              x *= x;\n              n /= 2;\n           }\n       }\n    }\n}\n"
    },
    "contracts/OrderedSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\n/**\n * @title OrderedSet\n * @dev Data structure. It has the properties of a mapping for addresses, but members are ordered\n * and can be enumerated. Items can be inserted only at the head or the tail, but can be removed\n * from anywhere. Append, prepend, remove and contains are O(1). Length and enumerate O(N). InsertAfter\n * and insertBefore could be implemented at O(1).\n * @author Alberto Cuesta Cañada\n */\nlibrary OrderedSet {\n\n    event ItemInserted(address prev, address inserted, address next);\n    event ItemRemoved(address removed);\n\n    struct Set {\n        mapping (address => address) next;\n        mapping (address => address) prev;\n    }\n\n    /**\n     * @dev Insert an item as the new tail.\n     */\n    function append(Set storage set, address item)\n        internal\n    {\n        _insert(\n            set,\n            tail(set),\n            item,\n            address(0)\n        );\n    }\n\n    /**\n     * @dev Insert an item as the new head.\n     */\n    function prepend(Set storage set, address item)\n        internal\n    {\n        _insert(\n            set,\n            address(0),\n            item,\n            head(set)\n        );\n    }\n\n    /**\n     * @dev Remove an item.\n     */\n    function remove(Set storage set, address item)\n        internal\n    {\n        require(\n            item != address(0),\n            \"OrderedSet: Cannot remove the empty address\"\n        );\n        require(\n            contains(set, item) == true,\n            \"OrderedSet: Cannot remove a non existing item\"\n        );\n        set.next[set.prev[item]] = set.next[item];\n        set.prev[set.next[item]] = set.prev[item];\n        delete set.next[item];\n        delete set.prev[item];\n        emit ItemRemoved(item);\n    }\n\n    /**\n     * @dev Returns the Head.\n     */\n    function head(Set storage set)\n        internal\n        view\n        returns (address)\n    {\n        return set.next[address(0)];\n    }\n\n    /**\n     * @dev Returns the Tail.\n     */\n    function tail(Set storage set)\n        internal\n        view\n        returns (address)\n    {\n        return set.prev[address(0)];\n    }\n\n    /**\n     * @dev Returns true if the item is in the set.\n     */\n    function contains(Set storage set, address item)\n        internal\n        view\n        returns (bool)\n    {\n        return head(set) == item ||\n            set.next[item] != address(0) ||\n            set.prev[item] != address(0);\n    }\n\n    /**\n     * @dev Return the number of items in the set.\n     */\n    function length(Set storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 count = 0;\n        address item = head(set);\n        while (item != address(0)) {\n            count += 1;\n            item = set.next[item];\n        }\n        return count;\n    }\n\n    /**\n     * @dev Return an array with all items in the set, from Head to Tail.\n     */\n    function enumerate(Set storage set)\n        internal\n        view\n        returns (address[] memory)\n    {\n        address[] memory items = new address[](length(set));\n        uint256 count = 0;\n        address item = head(set);\n        while (item != address(0)) {\n            items[count] = item;\n            count += 1;\n            item = set.next[item];\n        }\n        return items;\n    }\n\n    /**\n     * @dev Insert an item between another two..\n     */\n    function _insert(\n        Set storage set,\n        address prev_,\n        address item,\n        address next_\n    )\n        private\n    {\n        require(\n            item != address(0),\n            \"OrderedSet: Cannot insert the empty address\"\n        );\n        require(\n            contains(set, item) == false,\n            \"OrderedSet: Cannot insert an existing item\"\n        );\n        set.next[prev_] = item;\n        set.next[item] = next_;\n        set.prev[next_] = item;\n        set.prev[item] = prev_;\n        emit ItemInserted(prev_, item, next_);\n    }\n}\n\n/**\n * @title OrderedUint256Set\n * @dev Data structure. It has the properties of a mapping for addresses, but members are ordered\n * and can be enumerated. Items can be inserted only at the head or the tail, but can be removed\n * from anywhere. Append, prepend, remove and contains are O(1). Length and enumerate O(N). InsertAfter\n * and insertBefore could be implemented at O(1).\n * @author Alberto Cuesta Cañada\n */\nlibrary OrderedUint256Set {\n\n    event ItemInserted(uint256 prev, uint256 inserted, uint256 next);\n    event ItemRemoved(uint256 removed);\n\n    struct Set {\n        mapping (uint256 => uint256) next;\n        mapping (uint256 => uint256) prev;\n    }\n\n    /**\n     * @dev Insert an item as the new tail.\n     */\n    function append(Set storage set, uint256 item)\n        internal\n    {\n        _insert(\n            set,\n            tail(set),\n            item,\n            uint256(0)\n        );\n    }\n\n    /**\n     * @dev Insert an item as the new head.\n     */\n    function prepend(Set storage set, uint256 item)\n        internal\n    {\n        _insert(\n            set,\n            uint256(0),\n            item,\n            head(set)\n        );\n    }\n\n    /**\n     * @dev Remove an item.\n     */\n    function remove(Set storage set, uint256 item)\n        internal\n    {\n        require(\n            item != uint256(0),\n            \"OrderedSet: Cannot remove the empty address\"\n        );\n        require(\n            contains(set, item) == true,\n            \"OrderedSet: Cannot remove a non existing item\"\n        );\n        set.next[set.prev[item]] = set.next[item];\n        set.prev[set.next[item]] = set.prev[item];\n        delete set.next[item];\n        delete set.prev[item];\n        emit ItemRemoved(item);\n    }\n\n    /**\n     * @dev Returns the Head.\n     */\n    function head(Set storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        return set.next[uint256(0)];\n    }\n\n    /**\n     * @dev Returns the Tail.\n     */\n    function tail(Set storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        return set.prev[uint256(0)];\n    }\n\n    /**\n     * @dev Returns true if the item is in the set.\n     */\n    function contains(Set storage set, uint256 item)\n        internal\n        view\n        returns (bool)\n    {\n        return head(set) == item ||\n            set.next[item] != uint256(0) ||\n            set.prev[item] != uint256(0);\n    }\n\n    /**\n     * @dev Return the number of items in the set.\n     */\n    function length(Set storage set)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 count = 0;\n        uint256 item = head(set);\n        while (item != uint256(0)) {\n            count += 1;\n            item = set.next[item];\n        }\n        return count;\n    }\n\n    /**\n     * @dev Return an array with all items in the set, from Head to Tail.\n     */\n    function enumerate(Set storage set)\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory items = new uint256[](length(set));\n        uint256 count = 0;\n        uint256 item = head(set);\n        while (item != uint256(0)) {\n            items[count] = item;\n            count += 1;\n            item = set.next[item];\n        }\n        return items;\n    }\n\n    /**\n     * @dev Insert an item between another two..\n     */\n    function _insert(\n        Set storage set,\n        uint256 prev_,\n        uint256 item,\n        uint256 next_\n    )\n       internal \n    {\n        require(\n            item != uint256(0),\n            \"OrderedSet: Cannot insert the empty address\"\n        );\n        require(\n            contains(set, item) == false,\n            \"OrderedSet: Cannot insert an existing item\"\n        );\n        set.next[prev_] = item;\n        set.next[item] = next_;\n        set.prev[next_] = item;\n        set.prev[item] = prev_;\n        emit ItemInserted(prev_, item, next_);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}